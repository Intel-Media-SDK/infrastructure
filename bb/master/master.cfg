# Copyright (c) 2018 Intel Corporation
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from enum import Enum

from buildbot.changes.gitpoller import GitPoller
from buildbot.changes.github import GitHubPullrequestPoller
from buildbot.plugins import schedulers, util, steps, worker, reporters
import config

class Stage(Enum):
    CLEAN = "clean"
    EXTRACT = "extract"
    BUILD = "build"
    INSTALL = "install"
    PACK = "pack"
    COPY = "copy"

def init_build_factory(conf_file="conf_linux_public.py",
                       product_type=config.MASTER_PRODUCT_TYPE,
                       api_latest=False,
                       w_error=True):
    build_factory = util.BuildFactory()

    #Build by stages: clean, extract, build, install, pack, copy
    for stage in Stage:
        shell_commands = [config.RUN_COMMAND,
                          "build_runner.py",
                          "--build-config",
                          util.Interpolate(r"%(prop:builddir)s/../product-configs/%(kw:conf_file)s",
                                           conf_file=conf_file),
                          "--root-dir", util.Interpolate(r"%(prop:builddir)s/build_dir"),
                          "--changed-repo", util.Interpolate(config.REPO_INFO),
                          "--build-type", config.BUILD_TYPE,
                          "--build-event", "commit",
                          "--product-type", product_type,
                          "--repo-url", util.Interpolate(r"%(prop:repository)s"),
                          "--stage", stage.value,
                         ]
        if api_latest:
            shell_commands.append("api_latest=True")
        if w_error:
            shell_commands.append("w_error_latest=True")

        build_factory.addStep(
            steps.ShellCommand(command=shell_commands,
                               workdir=r"../infrastructure/build_scripts",
                               name=stage.value))

    #Trigger tests
    if product_type == config.MASTER_PRODUCT_TYPE:
        build_factory.addStep(steps.Trigger(schedulerNames=[config.TEST],
                                            waitForFinish=False,
                                            updateSourceStamp=True))
    else:
        build_factory.addStep(steps.Trigger(schedulerNames=[config.TEST_API_LATEST],
                                            waitForFinish=False,
                                            updateSourceStamp=True))
    return build_factory

def init_test_factory(product_type=config.MASTER_PRODUCT_TYPE):
    test_factory = util.BuildFactory()
    test_factory.addStep(
        steps.ShellCommand(command=[config.RUN_COMMAND,
                                    "test_adapter.py",
                                    "--branch", util.Interpolate(r"%(prop:branch)s"),
                                    "--build-event", "commit",
                                    "--product-type", product_type,
                                    "--commit-id", util.Interpolate(r"%(prop:revision)s"),
                                    "--build-type", config.BUILD_TYPE],
                           workdir=r"../infrastructure/ted_adapter"))
    return test_factory


c = BuildmasterConfig = {}

c["workers"] = []

# Add workers
for worker_ in config.WORKERS.values():
    for w_name, prop in worker_.items():
        c["workers"].append(worker.Worker(w_name, config.WORKER_PASS,
                                          properties=prop,
                                          max_builds=1)) # To disable parallel builds on one worker

c["protocols"] = {"pb": {"port": config.WORKER_PORT}}

# Basic config
c["buildbotNetUsageData"] = config.BUILDBOT_NET_USAGE_DATA
c["title"] = config.BUILDBOT_TITLE
c["titleURL"] = config.REPO_URL
c["buildbotURL"] = config.BUILDBOT_URL


# Schedulers
c["schedulers"] = [
    schedulers.SingleBranchScheduler(name=config.BUILD_MASTER,
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch="master"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILD_MASTER]),
    schedulers.SingleBranchScheduler(name=config.BUILD_NOT_MASTER,
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re="(?!master)"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILD_NOT_MASTER]),
    schedulers.SingleBranchScheduler(name=config.BUILD_API_LATEST,
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re=".+?"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILD_API_LATEST]),
    schedulers.SingleBranchScheduler(name=config.BUILD_GCC_LATEST["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re=".+?"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILD_GCC_LATEST["name"]]),
    schedulers.Triggerable(name=config.TEST,
                           builderNames=[config.TEST]),
    schedulers.Triggerable(name=config.TEST_API_LATEST,
                           builderNames=[config.TEST_API_LATEST])]


#Init build factories
build_factory = init_build_factory("conf_linux_public.py",
                                   config.MASTER_PRODUCT_TYPE,
                                   api_latest=False)

#Init build factory for other branches (all except master)
build_not_master_factory = init_build_factory("conf_linux_public.py",
                                              config.MASTER_PRODUCT_TYPE,
                                              api_latest=False)

build_api_latest_factory = init_build_factory("conf_linux_public.py",
                                              "api_latest",
                                              api_latest=True)

build_gcc_latest_factory = init_build_factory(config.BUILD_GCC_LATEST["product_conf_file"],
                                              config.BUILD_GCC_LATEST["product_type"],
                                              api_latest=True,
                                              w_error=False)
#Init tests
test_factory = init_test_factory(config.MASTER_PRODUCT_TYPE)
test_api_factory = init_test_factory("api_latest")


# Builders
c["builders"] = [
    util.BuilderConfig(name=config.BUILD_MASTER,
                       workernames=list(config.WORKERS[config.BUILD].keys()),
                       factory=build_factory),
    util.BuilderConfig(name=config.BUILD_NOT_MASTER,
                       workernames=list(config.WORKERS[config.BUILD].keys()),
                       factory=build_not_master_factory),
    util.BuilderConfig(name=config.BUILD_API_LATEST,
                       workernames=list(config.WORKERS[config.BUILD].keys()),
                       factory=build_api_latest_factory),
    util.BuilderConfig(name=config.BUILD_GCC_LATEST["name"],
                       workernames=list(config.WORKERS[config.BUILD_GCC_LATEST["name"]].keys()),
                       factory=build_gcc_latest_factory),
    util.BuilderConfig(name=config.TEST,
                       workernames=list(config.WORKERS[config.TEST].keys()),
                       factory=test_factory),
    util.BuilderConfig(name=config.TEST_API_LATEST,
                       workernames=list(config.WORKERS[config.TEST].keys()),
                       factory=test_api_factory)]


# Push status of build to the Github
c["services"] = [
    reporters.GitHubStatusPush(token=config.GITHUB_TOKEN,
                               context=util.Interpolate("buildbot/%(prop:buildername)s"),
                               startDescription="Started",
                               endDescription="Done",
                               verbose=True)]
# Will be useful for implementing build notifications in the future
#    reporters.GitHubCommentPush(token=config.GITHUB_TOKEN,
#                                 startDescription="Started (comment)",
#                                 endDescription="Done (comment)",
#                                 verbose=True,
#                                 debug=True)]

c["change_source"] = []

def pull_request_filter(pull_request_message):
    # Include only changes from fork repositories
    if pull_request_message["head"]["repo"]["full_name"] == config.GITHUB_REPOSITORY:
        return False
    return True

# To process only the changes from forked repositories
c["change_source"].append(GitHubPullrequestPoller(
    owner=config.GITHUB_OWNER,
    repo=config.GITHUB_OWNERS_REPO,
    token=config.GITHUB_TOKEN,
    pullrequest_filter=pull_request_filter,
    category="mediasdk",
    pollInterval=config.POLL_INTERVAL, # Interval of PR`s checking
    pollAtLaunch=True))

c["change_source"].append(GitPoller(
    repourl=f"{config.REPO_URL}.git",
    workdir="gitpoller-workdir", # Dir for the output of git remote-ls command
    branches=True, # Poll all branches
    category="mediasdk",
    pollInterval=config.POLL_INTERVAL,
    pollAtLaunch=True))


# Web Interface
c["www"] = dict(port=int(config.PORT),
                plugins={"console_view": True})

# Database
c["db"] = {"db_url": config.DATABASE_URL}

c["collapseRequests"] = False # It disables automatic merging of requests
                              # (to build EACH commit)
