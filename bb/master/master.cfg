# Copyright (c) 2018 Intel Corporation
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from enum import Enum

from buildbot.changes.gitpoller import GitPoller
from buildbot.changes.github import GitHubPullrequestPoller
from buildbot.plugins import schedulers, util, steps, worker, reporters
import config

class Stage(Enum):
    CLEAN = "clean"
    EXTRACT = "extract"
    BUILD = "build"
    INSTALL = "install"
    PACK = "pack"
    COPY = "copy"

def init_build_factory(build_specification):
    conf_file = build_specification["product_conf_file"]
    product_type = build_specification["product_type"]
    build_type = build_specification["build_type"]
    api_latest = build_specification["api_latest"]
    compiler = build_specification["compiler"]
    compiler_version = build_specification["compiler_version"]
    build_factory = util.BuildFactory()

    #Build by stages: clean, extract, build, install, pack, copy
    for stage in Stage:
        shell_commands = [config.RUN_COMMAND,
                          "build_runner.py",
                          "--build-config",
                          util.Interpolate(r"%(prop:builddir)s/../product-configs/%(kw:conf_file)s",
                                           conf_file=conf_file),
                          "--root-dir", util.Interpolate(r"%(prop:builddir)s/build_dir"),
                          "--changed-repo", util.Interpolate(config.REPO_INFO),
                          "--build-type", build_type,
                          "--build-event", "commit",
                          "--product-type", product_type,
                          "--repo-url", util.Interpolate(r"%(prop:repository)s"),
                          "--stage", stage.value,
                         ]
        if api_latest:
            shell_commands.append("api_latest=True")

        shell_commands.append(f"compiler={compiler}")
        shell_commands.append(f"compiler_version={compiler_version}")

        build_factory.addStep(
            steps.ShellCommand(command=shell_commands,
                               workdir=r"../infrastructure/build_scripts",
                               name=stage.value))

    #Trigger tests
    if product_type == "linux":
        build_factory.addStep(steps.Trigger(schedulerNames=[config.TEST["name"]],
                                            waitForFinish=False,
                                            updateSourceStamp=True))
    elif product_type == "api_latest":
        build_factory.addStep(steps.Trigger(schedulerNames=[config.TEST_API_LATEST["name"]],
                                            waitForFinish=False,
                                            updateSourceStamp=True))
    return build_factory

def init_test_factory(test_specification):
    product_type = test_specification["product_type"]
    build_type = test_specification["build_type"]
    test_factory = util.BuildFactory()

    test_factory.addStep(
        steps.ShellCommand(command=[config.RUN_COMMAND,
                                    "test_adapter.py",
                                    "--branch", util.Interpolate(r"%(prop:branch)s"),
                                    "--build-event", "commit",
                                    "--product-type", product_type,
                                    "--commit-id", util.Interpolate(r"%(prop:revision)s"),
                                    "--build-type", build_type],
                           workdir=r"../infrastructure/ted_adapter"))
    return test_factory


c = BuildmasterConfig = {}

c["workers"] = []

# Add workers
for worker_ in config.WORKERS.values():
    for w_name, prop in worker_.items():
        c["workers"].append(worker.Worker(w_name, config.WORKER_PASS,
                                          properties=prop,
                                          max_builds=1)) # To disable parallel builds on one worker

c["protocols"] = {"pb": {"port": config.WORKER_PORT}}

# Basic config
c["buildbotNetUsageData"] = config.BUILDBOT_NET_USAGE_DATA
c["title"] = config.BUILDBOT_TITLE
c["titleURL"] = config.REPO_URL
c["buildbotURL"] = config.BUILDBOT_URL


# Schedulers
c["schedulers"] = [
    schedulers.SingleBranchScheduler(name=config.BUILDERS["build_master"]["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch="master"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILDERS["build_master"]["name"]]),

    schedulers.SingleBranchScheduler(name=config.BUILDERS["build_not_master"]["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re="(?!master)"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILDERS["build_not_master"]["name"]]),

    schedulers.SingleBranchScheduler(name=config.BUILDERS["build_api_latest"]["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re=".+?"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILDERS["build_api_latest"]["name"]]),

    schedulers.SingleBranchScheduler(name=config.BUILDERS["build_gcc_latest"]["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re=".+?"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILDERS["build_gcc_latest"]["name"]]),

    schedulers.SingleBranchScheduler(name=config.BUILDERS["build_clang_latest"]["name"],
                                     change_filter=util.ChangeFilter(category="mediasdk",
                                                                     branch_re=".+?"),
                                     treeStableTimer=config.BUILDBOT_TREE_STABLE_TIMER,
                                     builderNames=[config.BUILDERS["build_clang_latest"]["name"]]),

    schedulers.Triggerable(name=config.TEST["name"],
                           builderNames=[config.TEST["name"]]),

    schedulers.Triggerable(name=config.TEST_API_LATEST["name"],
                           builderNames=[config.TEST_API_LATEST["name"]])]

# Builders
c["builders"] = [
    util.BuilderConfig(name=config.BUILDERS["build_master"]["name"],
                       workernames=[config.WORKERS[config.BUILD].keys()],
                       factory=init_build_factory(config.BUILDERS["build_master"])),

    util.BuilderConfig(name=config.BUILDERS["build_not_master"]["name"],
                       workernames=[config.WORKERS[config.BUILD].keys()],
                       factory=init_build_factory(config.BUILDERS["build_not_master"])),

    util.BuilderConfig(name=config.BUILDERS["build_api_latest"]["name"],
                       workernames=[config.WORKERS[config.BUILD].keys()],
                       factory=init_build_factory(config.BUILDERS["build_api_latest"])),

    util.BuilderConfig(name=config.BUILDERS["build_gcc_latest"]["name"],
                       workernames=[config.WORKERS[config.BUILDERS["build_gcc_latest"]["name"]].keys()],
                       factory=init_build_factory(config.BUILDERS["build_gcc_latest"])),

    util.BuilderConfig(name=config.BUILDERS["build_clang_latest"]["name"],
                       workernames=[config.WORKERS[config.BUILDERS["build_gcc_latest"]["name"]].keys()],
                       factory=init_build_factory(config.BUILDERS["build_clang_latest"])),

    util.BuilderConfig(name=config.TEST["name"],
                       workernames=[config.WORKERS[config.TEST["name"]].keys()],
                       factory=init_test_factory(config.TEST)),

    util.BuilderConfig(name=config.TEST_API_LATEST["name"],
                       workernames=[config.WORKERS[config.TEST["name"]].keys()],
                       factory=init_test_factory(config.TEST_API_LATEST))]


# Push status of build to the Github
c["services"] = [
    reporters.GitHubStatusPush(token=config.GITHUB_TOKEN,
                               context=util.Interpolate("buildbot/%(prop:buildername)s"),
                               startDescription="Started",
                               endDescription="Done",
                               verbose=True)]
# Will be useful for implementing build notifications in the future
#    reporters.GitHubCommentPush(token=config.GITHUB_TOKEN,
#                                 startDescription="Started (comment)",
#                                 endDescription="Done (comment)",
#                                 verbose=True,
#                                 debug=True)]

c["change_source"] = []

def pull_request_filter(pull_request_message):
    # Include only changes from fork repositories
    if pull_request_message["head"]["repo"]["full_name"] == config.GITHUB_REPOSITORY:
        return False
    return True

# To process only the changes from forked repositories
c["change_source"].append(GitHubPullrequestPoller(
    owner=config.GITHUB_OWNER,
    repo=config.GITHUB_OWNERS_REPO,
    token=config.GITHUB_TOKEN,
    pullrequest_filter=pull_request_filter,
    category="mediasdk",
    pollInterval=config.POLL_INTERVAL, # Interval of PR`s checking
    pollAtLaunch=True))

c["change_source"].append(GitPoller(
    repourl=f"{config.REPO_URL}.git",
    workdir="gitpoller-workdir", # Dir for the output of git remote-ls command
    branches=True, # Poll all branches
    category="mediasdk",
    pollInterval=config.POLL_INTERVAL,
    pollAtLaunch=True))


# Web Interface
c["www"] = dict(port=int(config.PORT),
                plugins={"console_view": True})

# Database
c["db"] = {"db_url": config.DATABASE_URL}

c["collapseRequests"] = False # It disables automatic merging of requests
                              # (to build EACH commit)
